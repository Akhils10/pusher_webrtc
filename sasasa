var app = new Vue({
        el: '#app',
        data: {
            inCall: false,
            connected: false,
            usersOnline: 0,
            id: '',
            users: []
        },
        mounted: function() {
            channel.bind('pusher:subscription_succeeded', (members) => {
                //set the member count
                this.usersOnline = members.count;
                this.id = channel.members.me.id;
                members.each((member) => {
                    if (member.id != channel.members.me.id) {
                        this.users.push(member.id)
                    }
                });

                this.subscribeUserForCallNotification();
            })

            channel.bind('pusher:member_added', (member) => {
                this.users.push(member.id)
            });

            channel.bind('pusher:member_removed', (member) => {
                // for remove member from list:
                var index = this.users.indexOf(member.id);
                this.users.splice(index, 1);
            });



        },

        methods: {
            subscribeUserForCallNotification: function() {
                peerConn = new RTCPeerConnection(peerConnCfg);
                peerConn.onicecandidate = this.onIceCandidateHandler;
                peerConn.onaddstream = this.onAddStreamHandler;

                channel.bind('client-' + this.id + 'call', (offerData) => {
                    // call has come in. accept or reject
                    var call = confirm("You have a call from " + offerData.from);
                    if (call == true) {
                        this.acceptCall(offerData)
                    } else {
                        this.rejectCall(offerData)
                    }
                });

                channel.bind('client-' + this.id + 'endcall', (endData) => {
                    // End the current call
                });

                channel.bind('client-' + this.id + 'sendanswer', (recievedAnswer) => {
                    //console.log('answer recieved');
                    //console.log(recievedAnswer);

                    // End the current call
                    this.connected = recievedAnswer.from;

                    if (recievedAnswer.answer) {
                        peerConn.setRemoteDescription(new RTCSessionDescription(recievedAnswer.answer));
                    }
                    //deal with the answer
                });


                channel.bind('client-' + this.id + 'candidate', (recievedAnswer) => {
                    console.log('candidate recieved');
                    console.log(recievedAnswer);
                    // End the current call

                    if (recievedAnswer.candidate) {
                        peerConn.addIceCandidate(new RTCIceCandidate(recievedAnswer.candidate));
                    }
                    //deal with the answer
                });

            },
            onIceCandidateHandler: function(evt) {
                if (!evt.candidate) {
                    return;
                } else {
                    if (!evt.remoteDescription) return;
                    console.log('candidate is', evt);
                    peerConn.addIceCandidate(new RTCIceCandidate(evt.candidate), () => {

                    }, error);
                    if (this.connected) {
                        channel.trigger('client-' + this.connected + 'candidate', evt);
                    }

                }


            },
            onAddStreamHandler: function(evt) {
                this.$refs.remoteVideo.src = URL.createObjectURL(evt.stream);
            },
            callUser: function(toId) {
                navigator.getUserMedia(constraints, (stream) => {
                    this.inCall = true;
                    this.$refs.localVideo.src = URL.createObjectURL(stream);
                    peerConn.addStream(stream);
                    this.notifyUserOfCall(toId);
                }, error);
            },
            notifyUserOfCall: function(toId) {

                peerConn.createOffer((offer) => {
                    peerConn.setLocalDescription(new RTCSessionDescription(offer), () => {
                        //send the offer via pusher
                        channel.trigger('client-' + toId + 'call', {
                            to: toId,
                            from: this.id,
                            offer: offer
                        });
                    }, error);
                }, error);
            },

            acceptCall: function(recievedOffer) {
                navigator.getUserMedia(constraints, (stream) => {
                    this.$refs.localVideo.src = URL.createObjectURL(stream);
                    peerConn.addStream(stream);
                    peerConn.setRemoteDescription(new RTCSessionDescription(recievedOffer.offer), () => {
                        peerConn.createAnswer((answer) => {
                            peerConn.setLocalDescription(new RTCSessionDescription(answer), () => {
                                // send the answer to a server to be forwarded back to the caller
                                this.inCall = true;
                                this.connected = recievedOffer.from;

                                channel.trigger('client-' + recievedOffer.from + 'sendanswer', {
                                    from: this.id,
                                    answer: answer
                                });
                            }, error);
                        }, error);
                    }, error);
                }, error);
            },

            rejectCall: function(offer) {

            }

        }
    })